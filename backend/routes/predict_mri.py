import os
import tempfile
import torch
import numpy as np
import torchvision.transforms as T
from PIL import Image
from fastapi import APIRouter, UploadFile, File
from typing import List, Dict

# Model Imports
from backend.models.unet import UNet
from backend.models.classifier import MRIDiseaseClassifier
from backend.modules.mri_service import analyze_dicom_zip

router = APIRouter()

# =====================
# CONFIG & CONSTANTS
# =====================
DEVICE = "cpu"
IMAGE_SIZE = 256
SEG_MODEL_PATH = "backend/models/unet_brisc.pth"
CLS_MODEL_PATH = "backend/models/mri_disease_model.pth"

TUMOR_RISK_MAP: Dict[str, Dict] = {
    "glioma": {
        "risks": ["Rapid growth", "Seizures", "Cognitive impairment", "High recurrence"]
    },
    "meningioma": {
        "risks": ["Intracranial pressure", "Vision problems", "Compression of brain structures"]
    },
    "pituitary": {
        "risks": ["Hormonal imbalance", "Vision loss", "Endocrine dysfunction"]
    },
    "notumor": {
        "risks": ["Normal brain appearance", "Routine monitoring recommended"]
    }
}

# =====================
# MODEL INITIALIZATION
# =====================
# Load Segmentation Model
seg_model = UNet(in_channels=1, num_classes=2)
if os.path.exists(SEG_MODEL_PATH):
    seg_model.load_state_dict(torch.load(SEG_MODEL_PATH, map_location=DEVICE, weights_only=True))
seg_model.to(DEVICE).eval()

# Load Classification Model
if os.path.exists(CLS_MODEL_PATH):
    cls_ckpt = torch.load(CLS_MODEL_PATH, map_location=DEVICE, weights_only=True)
    CLASS_NAMES = cls_ckpt["classes"]
    cls_model = MRIDiseaseClassifier(num_classes=len(CLASS_NAMES))
    cls_model.load_state_dict(cls_ckpt["model_state"])
    cls_model.to(DEVICE).eval()
else:
    CLASS_NAMES = ["Unknown"]

# =====================
# PREPROCESSING
# =====================
seg_transform = T.Compose([T.Resize((IMAGE_SIZE, IMAGE_SIZE)), T.ToTensor()])
cls_transform = T.Compose([
    T.Resize((224, 224)),
    T.Grayscale(num_output_channels=3),
    T.ToTensor(),
    T.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# =====================
# AI CORE FUNCTIONS
# =====================
def segment_tumor(image_tensor):
    with torch.no_grad():
        logits = seg_model(image_tensor)
        pred = torch.argmax(logits, dim=1)
    return pred[0].cpu().numpy()

def analyze_mask(mask):
    tumor_pixels = int((mask == 1).sum())
    if tumor_pixels < 100:
        return {"tumor_detected": False, "tumor_size_pixels": 0, "tumor_location": None}

    coords = np.column_stack(np.where(mask == 1))
    y, x = coords.mean(axis=0)
    return {
        "tumor_detected": True,
        "tumor_size_pixels": tumor_pixels,
        "tumor_location": {"x": float(x), "y": float(y)}
    }

def classify_disease(image_tensor):
    with torch.no_grad():
        logits = cls_model(image_tensor)
        probs = torch.softmax(logits, dim=1)[0]
    idx = probs.argmax().item()
    return {
        "tumor_type": CLASS_NAMES[idx],
        "confidence": round(probs[idx].item(), 4),
        "probabilities": {CLASS_NAMES[i]: round(probs[i].item(), 4) for i in range(len(CLASS_NAMES))}
    }

# =====================
# INTEGRATED LOGIC
# =====================
def run_ai_analysis(heatmap_path: str):
    """
    Runs AI analysis on the heatmap slice generated by mri_service.
    """
    image = Image.open(heatmap_path).convert("L")

    # 1. Classification
    cls_input = cls_transform(image).unsqueeze(0).to(DEVICE)
    cls_result = classify_disease(cls_input)

    # 2. Risks
    risk_info = TUMOR_RISK_MAP.get(cls_result["tumor_type"].lower(), {"risks": ["Unknown type"]})

    # 3. Segmentation (if applicable)
    if cls_result["tumor_type"].lower() == "notumor":
        seg_result = {"tumor_detected": False, "tumor_size_pixels": 0, "tumor_location": None}
    else:
        seg_input = seg_transform(image).unsqueeze(0).to(DEVICE)
        mask = segment_tumor(seg_input)
        seg_result = analyze_mask(mask)

    return {
        "segmentation": seg_result,
        "classification": cls_result,
        "risk_analysis": risk_info
    }

# =====================
# ROUTE HANDLER
# =====================
@router.post("/predict/mri")
async def predict_mri(file: UploadFile = File(...)):
    # 1. Save uploaded zip to temp file
    with tempfile.NamedTemporaryFile(delete=False, suffix=".zip") as tmp:
        tmp.write(await file.read())
        zip_path = tmp.name

    try:
        # 2. Process DICOM -> VTI & Heatmap PNG
        # analyze_dicom_zip handles extraction and 3D reconstruction
        mri_data = analyze_dicom_zip(zip_path)

        # 3. Run AI analysis on the generated heatmap slice
        # The heatmap_slice path is absolute/relative from static, adjust accordingly
        heatmap_url_path = mri_data["heatmap_slice"]
        relative_file_path = heatmap_url_path.replace("/static", "backend/static", 1).lstrip("/")
        static_path = os.path.join(os.getcwd(), relative_file_path)
        ai_results = run_ai_analysis(static_path)

        # 4. Merge results
        return {**mri_data,  **ai_results}

    finally:
        if os.path.exists(zip_path):
            os.remove(zip_path)